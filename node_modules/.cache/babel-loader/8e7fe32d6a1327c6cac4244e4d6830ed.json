{"ast":null,"code":"class Game {\n  constructor(dimension) {\n    this.getRandomNumber = () => Math.random() > .1 ? 2 : 4;\n\n    this.getRandomArrayIndex = arr => Math.floor(arr.length * Math.random());\n\n    this.onMove = callback => this.moveCallback = callback;\n\n    this.dimension = dimension;\n    this.setupNewGame();\n  }\n\n  setupNewGame() {\n    const board = this.blankGrid();\n    this.addNumber(board);\n    this.addNumber(board);\n    this.gameState = {\n      board: this.convertTo1D(board),\n      score: 0,\n      won: false,\n      over: false\n    };\n  }\n\n  addNumber(board) {\n    const openings = [],\n          {\n      dimension\n    } = this;\n\n    for (let i = 0; i < dimension; i++) {\n      for (let j = 0; j < dimension; j++) {\n        if (board[i][j] === 0) openings.push({\n          col: i,\n          row: j\n        });\n      }\n    }\n\n    if (openings.length === 0) return;\n    const target = openings[this.getRandomArrayIndex(openings)];\n    board[target.col][target.row] = this.getRandomNumber() > 0.1 ? 2 : 4;\n  }\n\n  move(direction) {\n    let turned = false,\n        transposed = false,\n        notArrowKey = false;\n    const board = this.convertTo2D(this.gameState.board);\n\n    switch (direction) {\n      case 'up':\n        //turnBoard();\n        turned = true;\n        break;\n\n      case 'left':\n        //turnBoard();\n        //transposeBoard();\n        turned = true;\n        transposed = true;\n        break;\n\n      case 'right':\n        //transposeBoard();\n        transposed = true;\n        break;\n\n      default:\n        notArrowKey = direction !== 'down';\n    }\n\n    if (notArrowKey) return;\n    const copy = this.duplicate();\n\n    for (let i = 0; i < this.dimension; i++) board[i] = translate(board[i]);\n\n    const different = this.isDifferent(copy, grid);\n    if (turned) board = turnBoard();\n    if (transposed) board = transposeBoard();\n    if (different) this.addNumber();\n  }\n\n  blankGrid() {\n    const grid = [],\n          {\n      dimension\n    } = this;\n\n    for (let i = 0; i < dimension; i++) {\n      grid.push(Array(dimension).fill(0));\n    }\n\n    return grid;\n  }\n\n  convertTo2D(board) {\n    const board2D = this.blankGrid();\n    board.forEach((value, idx) => board2D[Math.floor(idx % this.dimension)][Math.floor(idx / this.dimension)] = value);\n    return board2D;\n  }\n\n  convertTo1D(board) {\n    const {\n      dimension\n    } = this,\n          board1D = Array(dimension * dimension).fill(0);\n    let counter = 0;\n\n    for (let row = 0; row < dimension; row++) {\n      for (let col = 0; col < dimension; col++) {\n        board1D[counter++] = board[col][row];\n      }\n    }\n\n    return board1D;\n  }\n\n  duplicate(grid) {\n    const {\n      dimension\n    } = this,\n          copy = this.blankGrid();\n\n    for (let col = 0; col < dimension; col++) {\n      for (let row = 0; row < dimension; row++) {\n        copy[col][row] = grid[col][row];\n      }\n    }\n\n    return copy;\n  }\n\n  isDifferent(arr1, arr2) {\n    const {\n      dimension\n    } = this;\n\n    for (let i = 0; i < dimension; i++) {\n      for (let j = 0; j < dimension; j++) {\n        if (arr1[i][j] !== arr2[i][j]) return true;\n      }\n    }\n\n    return false;\n  }\n\n}\n\nexport default Game;","map":{"version":3,"sources":["/home/mitchell/School/426/2048/src/Game.js"],"names":["Game","constructor","dimension","getRandomNumber","Math","random","getRandomArrayIndex","arr","floor","length","onMove","callback","moveCallback","setupNewGame","board","blankGrid","addNumber","gameState","convertTo1D","score","won","over","openings","i","j","push","col","row","target","move","direction","turned","transposed","notArrowKey","convertTo2D","copy","duplicate","translate","different","isDifferent","grid","turnBoard","transposeBoard","Array","fill","board2D","forEach","value","idx","board1D","counter","arr1","arr2"],"mappings":"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","sourcesContent":["class Game {\n    \n    constructor(dimension) {\n        this.dimension = dimension;\n        this.setupNewGame()\n    }\n\n    setupNewGame() {\n        const board  = this.blankGrid();\n        this.addNumber(board);\n        this.addNumber(board);\n\n        this.gameState = {\n            board: this.convertTo1D(board),\n            score: 0,\n            won: false,\n            over: false\n        }\n    }\n\n    addNumber(board) {\n        const openings = [], { dimension } = this;\n\n        for (let i = 0; i < dimension; i++) {\n            for (let j = 0; j < dimension; j++) {\n                if (board[i][j] === 0) \n                    openings.push({col: i, row: j});\n                \n            }\n        }\n\n        if(openings.length === 0)\n            return;\n\n        const target = openings[this.getRandomArrayIndex(openings)];\n        board[target.col][target.row] = this.getRandomNumber() > 0.1 ? 2 : 4;\n    }\n\n    move(direction) {\n        let turned = false, transposed = false, notArrowKey = false;\n        const board = this.convertTo2D(this.gameState.board);\n\n        switch(direction) {\n            case 'up':\n                //turnBoard();\n                turned = true;\n                break;\n            case 'left':\n                //turnBoard();\n                //transposeBoard();\n                turned = true;\n                transposed = true;\n                break;\n            case 'right':\n                //transposeBoard();\n                transposed = true;\n                break;\n            default: notArrowKey = direction !== 'down';\n        }\n\n        if(notArrowKey)\n            return;\n\n        const copy = this.duplicate();\n\n        for(let i = 0; i < this.dimension; i++) \n            board[i] = translate(board[i])\n        \n\n        const different = this.isDifferent(copy, grid);\n\n        if(turned)\n            board = turnBoard();\n        \n        if(transposed)\n            board = transposeBoard();\n\n        if(different)\n            this.addNumber();\n\n    }\n\n    getRandomNumber = () => Math.random() > .1 ? 2 : 4;\n    getRandomArrayIndex = arr => Math.floor(arr.length * Math.random());\n\n    blankGrid() {\n        const grid = [], { dimension } = this;\n        for(let i = 0; i < dimension; i++) {\n            grid.push(Array(dimension).fill(0));\n        }\n        return grid;\n    }\n\n    onMove = callback => this.moveCallback = callback;\n\n    convertTo2D(board) {\n        const board2D = this.blankGrid();\n        board.forEach((value, idx) => board2D[Math.floor(idx % this.dimension)][Math.floor(idx / this.dimension)] = value);\n        return board2D;\n    }\n\n    convertTo1D(board) {\n        const { dimension } = this, board1D = Array(dimension*dimension).fill(0);\n\n        let counter = 0;\n\n        for(let row = 0; row < dimension; row++) {\n            for(let col = 0; col < dimension; col++) {\n                board1D[counter++] = board[col][row];\n            }\n        }\n        return board1D;\n    }\n\n    duplicate(grid) {\n        const { dimension } = this, copy = this.blankGrid();\n\n        for (let col = 0; col < dimension; col++) {\n            for (let row = 0; row < dimension; row++) {\n                copy[col][row] = grid[col][row];\n            }\n        }\n\n        return copy;\n    }\n\n    isDifferent(arr1, arr2) {\n        const { dimension } = this;\n        for (let i = 0; i < dimension; i++) {\n            for (let j = 0; j < dimension; j++) {\n                if (arr1[i][j] !== arr2[i][j]) \n                    return true;\n            }\n        }\n        return false;\n    }\n}\n\nexport default Game;"]},"metadata":{},"sourceType":"module"}